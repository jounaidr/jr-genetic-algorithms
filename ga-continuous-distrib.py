# -*- coding: utf-8 -*-
"""
Complete this code for continuous optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt


# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 50 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 100 # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CROSSOVER_RATE = 0.8 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.2 # Change MUTATION_RATE to obtain better fitness.

def generate_population(population_size, individual_size, lower_bound, upper_bound):
    population = np.zeros((population_size, individual_size))
    # Populate 'population' array with arrays of size individual_size of random float values between bounds
    for i in range(population_size):
        population[i,:] = np.random.uniform(lower_bound, upper_bound, (individual_size))
    
    return population


def sum_squares_compute_fitness(individual, target):
    # Generate an array of indexes from 1 to the individuals size
    indexes = np.arange(1, individual.size + 1)
    # Calculate the result based on: sum(ix^2), for the individuals values
    result = np.sum(indexes * (np.sqrt(np.abs(individual)) * np.sign(individual)))
    fitness = abs(result - target) # Calculate the results absolute distance from desired value

    return fitness


def selection(population):

    individual = []  # Update this line if you need to
    #TODO : Write your own code to for choice  of your selection operator
    
    return individual
    

def crossover(first_parent, second_parent):
    
    individual = [] # Update this line if you need to
    #TODO : Write your own code to for choice  of your crossover operator - you can use if condition to write more tan one ime of crossover operator
    
    return individual

def mutation(individual):
    
    #TODO : Write your own code to for choice  of your mutation operator - you can use if condition to write more tan one ime of crossover operator
    

    return individual

#TODO : You can increase number of function to be used to improve your GA code 




def next_generation(previous_population):
    #TODO : Write your own code to generate next 
    
    
    print(' ') # Print appropriate generation information here. 
    return next_generation
    
poop = generate_population(10, 5, -100, 100)

for i in range(10):
    yeet = sum_squares_compute_fitness(poop[i,:])
    print(yeet)

# # USE THIS MAIN FUNCTION TO COMPLETE YOUR CODE - MAKE SURE IT WILL RUN FROM COMOND LINE
# def main():
#     global POPULATION_SIZE
#     global GENERATIONS
#     global SOLUTION_FOUND
#
#     lower_bound = [] #Update this
#     upper_bound = [] #Update this
#
#     population = generate_population(POPULATION_SIZE, lower_bound, upper_bound)
#
#     print('complete code for a continuous optimization problem:')
#     while (True):  # TODO: write your termination condition here or within the loop
#         #TODO: write your generation propagation code here
#
#
#         #TODO: present innovative graphical illustration like plots and presentation of genetic algorithm results
#         #This is free (as you like) innovative part of the assessment.
#         break
#
#
# if __name__ == '__main__':
#     main()
    
    
    
