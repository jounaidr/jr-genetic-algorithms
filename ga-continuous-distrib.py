# -*- coding: utf-8 -*-
"""
Complete this code for continuous optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt


# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 50 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 100 # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CROSSOVER_RATE = 0.8 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.2 # Change MUTATION_RATE to obtain better fitness.

def generate_population(population_size, individual_size, lower_bound, upper_bound):
    # Generate empty 2D array of size population_size x individual_size
    population = np.zeros((population_size, individual_size))
    # Populate 'population' array with arrays of size individual_size of random float values between bounds
    for i in range(population_size):
        population[i,] = np.random.uniform(lower_bound, upper_bound, (individual_size))
    
    return population


def sum_squares_compute_fitness(population, target):
    # Generate a 1D array of indexes from 1 to the individuals size
    indexes = np.arange(1, population.shape[1] + 1)
    # Calculate the result based on: sum(ix^2), for each individuals values in the population
    result = np.sum(indexes * ((np.abs(population[0:,:]) ** 2) * np.sign(population[0:,:])), axis=1)
    fitness = abs(result[0:,] - target) # Calculate the results absolute distance from desired value

    return fitness


def selection_roulette(population, n):
    # Calculate the fitness of each individual in the population
    fitness = sum_squares_compute_fitness(population, 0) #TODO: OUTSIDE FUNCTION!!!!
    # Calculate each individuals fitness probability weighting using the total sum of each individuals fitness within the population
    probabilities = fitness[0:,] / np.sum(fitness)
    # Select two individuals from the population given the weighted probabilities, for the amount specified by 'n'
    selection = np.random.choice(a=population.shape[0], size=(n,2), p=probabilities)
    parents = np.take(population, selection, axis=0)

    return parents


def single_point_crossover(parents):
    # Generate an empty array the same shape as 'parents' array
    children = np.zeros_like(parents)
    crossover_point = random.randrange(1, parents.shape[2]) # Get a random index within the individuals index range
    # First child takes values from first parent up to crossover point, then the rest of the values from second parent
    # Second child takes values from second parent up to crossover point, then the rest of the values from first parent
    # This is done for each set of parents in 'parents' 3D array
    # This is done using NumPy horizontal stack: https://numpy.org/doc/stable/reference/generated/numpy.hstack.html
    children[:, 0, :] = np.hstack([parents[:, 0, :crossover_point],parents[:, 1, crossover_point:]])
    children[:, 1, :] = np.hstack([parents[:, 1, :crossover_point], parents[:, 0, crossover_point:]])
    
    return children


def uniform_mutation(individual, lower_bound, upper_bound, mutations):
    # Randomly choose indexes within the individuals range, for the given amount of 'mutations'
    indexes = np.random.choice(a=individual.size, replace=False, size=mutations)
    # Replace the chosen indexes with random real values within the specified bounds
    individual[indexes] = np.random.uniform(lower_bound, upper_bound, (mutations,))

    return individual


def next_generation(previous_population, population_size):
    # Calculate the fitness of each individual in the population
    fitness = sum_squares_compute_fitness(previous_population, 0) #TODO: OUTSIDE FUNCTION!!!!
    # Get indexes that correspond to the lowest fitness values for the amount specified by 'population_size'
    # This is done using NumPy 'argpartition' that has linear complexity: https://numpy.org/doc/stable/reference/generated/numpy.argpartition.html
    fittest_indexes = np.argpartition(fitness, population_size - 1)[:population_size]
    # Generate the next generation from fittest individuals in the population specified by 'fittest_indexes'
    next_generation = previous_population[fittest_indexes]

    return next_generation
    
poop = generate_population(10, 7, -5, 5)
#
# ahhh = next_generation(poop, 3)
#
yeet = selection_roulette(poop, 3)
#
eerrm = single_point_crossover(yeet)
#
# uniform_mutation(eerrm[0], -5, 5, 3)
#
# print("aa")

# for i in range(10):
#     yeet = sum_squares_compute_fitness(poop[i,:])
#     print(yeet)

# USE THIS MAIN FUNCTION TO COMPLETE YOUR CODE - MAKE SURE IT WILL RUN FROM COMOND LINE
def main():
    global POPULATION_SIZE
    global GENERATIONS
    global SOLUTION_FOUND

    global CROSSOVER_RATE
    global MUTATION_RATE

    lower_bound = -5
    upper_bound = 5

    initial_population = generate_population(POPULATION_SIZE, lower_bound, upper_bound)
    crossover_amount = round(POPULATION_SIZE * CROSSOVER_RATE)

    while (SOLUTION_FOUND):


        continue


if __name__ == '__main__':
    main()
    
    
    
